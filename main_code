//Testing variables
const long testSta = 200;     //starting period in ms
const long testTar = 40;      //target period in ms
const float testPer = 0.01;   //percent change
const float testChe = 1;       //check time in s
const int testNum = 16;       //number of states
const float testLDC = 0.5;    //percent LDC
const float testHDC = 0.5;    //percent HDC

/*------------------------------------------------------------------------------------*/
//Initialize system variables
const int systemFreq = 50000;           //Frequency of the PWM in Hz
const int sysResolution = 8;            //Number of bits for PWM channel
const long systemLowDutyCycle           //Low duty cycle value, an integer between
  = (long)((testLDC*256)-1);              //0 and 2^sysResolution
const long systemHighDutyCycle          //High duty cycle value
  = (long)((testHDC*256)-1);
const float systemPercent = testPer;    //Percentage change in the period
const long systemSP = testSta*1000;     //Default starting period in us
const long systemTP = testTar*1000;     //Default target period in us
const long systemCheckTime              //Default time between speed checks in us
  = (long)(testChe*1000000);
const int sysLarNumStates = testNum;    //Number of states for large stirring
const int sysSmlNumStates = 4;          //Number of states for small stirring

/*------------------------------------------------------------------------------------*/
//Coil pin numbers
/* 7 8 9
 * 4 5 6
 * 1 2 3 */
const int n1 = 21, s1 = 19;
const int n2 = 33, s2 = 32;
const int n3 = 18, s3 = 5;
const int n4 = 27, s4 = 14;
const int n5 = 2, s5 = 15;
const int n6 = 25, s6 = 26;
const int n7 = 16, s7 = 17;
const int n8 = 13, s8 = 12;
const int n9 = 4, s9 = 0;
 
/*------------------------------------------------------------------------------------*/
//Function declarations
long findPeriodChange(long inCurPer, long inTarPer);
void stopInterrupt();

/*------------------------------------------------------------------------------------*/
/* The large orient class is meant for stirring large beakers. It will turn on 2 coils,
 * which should be different polarity. Since the pin mode function is in this class,
 * it must be initialized before the small orient class. The state update function
 * will either turn off or turn on the coils. */
class largeOrient {
  int coilPin1n;
  int coilPin1s;
  int coilPin2n;
  int coilPin2s

  public:
  largeOrient(int pin1, int pin2, int pin3, int pin4) {
    coilPin1n = pin1;
    coilPin1s = pin2;
    coilPin2n = pin3;
    coilPin2s = pin4;
    pinMode(coilPin1n, OUTPUT);
    pinMode(coilPin1s, OUTPUT);
    pinMode(coilPin2n, OUTPUT);
    pinMode(coilPin2s, OUTPUT);
    digitalWrite(coilPin1n, LOW);
    digitalWrite(coilPin1s, LOW);
    digitalWrite(coilPin2n, LOW);
    digitalWrite(coilPin2s, LOW);
  }   //End largeOrient constructor 

  //1 = coil 1 north, 2 = coil 1 off, -1 = coil 2 north, -2 = coil 2 off, 0 = both off
  void stateUpdate(int inState) {
    if(inState == 1) {
      digitalWrite(coilPin1n, HIGH);
      digitalWrite(coilPin2s, HIGH);
    }
    if(inState == 2) {
      digitalWrite(coilPin1n, LOW);
      digitalWrite(coilPin2s, LOW);
    }
    if(inState == -1) {
      digitalWrite(coilPin2n, HIGH);
      digitalWrite(coilPin1s, HIGH);
    }
    if(inState == -2) {
      digitalWrite(coilPin2n, LOW);
      digitalWrite(coilPin1s, LOW);
    }
    else {
      digitalWrite(coilPin1n, LOW);
      digitalWrite(coilPin1s, LOW);
      digitalWrite(coilPin2n, LOW);
      digitalWrite(coilPin2s, LOW);
    }
  }   //End stateUpdate function
};    //End largeOrient class

/*------------------------------------------------------------------------------------*/
/* The small orient class is meant for stirring the small vials. It will turn on either
 * 4 or 5 coils, which is decided when initializing the object. When meant for 5 coils,
 * pin5 should be used for the center coil. Since the center pin is not used for large
 * stirring, the pin mode function for the center coil is here. */
class smallOrient {
  int numCoils;
  int coilPin1, coilPin2, coilPin3, coilPin4, coilPin5;

  public:
  smallOrient(int inNumber, int pin1, int pin2, int pin3, int pin4, int pin5) {
    numCoils = inNumber;
    coilPin1 = pin1;
    coilPin2 = pin2;
    coilPin3 = pin3;
    coilPin4 = pin4;
    if(numCoils == 5) {
      coilPin5 = pin5;
      pinMode(coilPin5, OUTPUT);
      digitalWrite(coilPin5, LOW);
    }
    else
      coilPin5 = 0;
  }   //End largeOrient constructor 

  void stateUpdate(int inState) {
    if(inState == 0) {
      digitalWrite(coilPin1, LOW);
      digitalWrite(coilPin2, LOW);
      digitalWrite(coilPin3, LOW);
      digitalWrite(coilPin4, LOW);
      if(numCoils == 5)
        digitalWrite(coilPin5, LOW);
    }
    else {
      digitalWrite(coilPin1, HIGH);
      digitalWrite(coilPin2, HIGH);
      digitalWrite(coilPin3, HIGH);
      digitalWrite(coilPin4, HIGH);
      if(numCoils == 5)
        digitalWrite(coilPin5, HIGH);
    }
  }   //End stateUpdate function
};    //End smallOrient class

/*------------------------------------------------------------------------------------*/
//Initialize program variables and objects

//State Variables
volatile int stopStirring = 0;
volatile int atSpeed = 0;
volatile int currentSN = 0;
volatile int smallMode = 0;

//Time variables
volatile unsigned long currentTime = 0;
volatile unsigned long prevTimeState = 0;
volatile unsigned long prevTimeCheck = 0;

//Period variables
volatile long currentPer = systemSP;
volatile long currentTar = systemTP;
volatile long currentInt = currentPer / sysLarNumStates;
volatile long periodChange = 0;

/* Remember that largeOrient sets the pin mode, so they must be initialized first.
 * All largeOrients must be initialized, even if they won't be used. */
//Initialize largeOrient instances
largeOrient l8n(n8, s8, n2, n2);
largeOrient l9n(n9, s9, n1, s1);
largeOrient l6n(n6, s6, n4, s4);
largeOrient l3n(n3, s3, n7, s7);

//Initialize smallOrient instances
smallOrient s1379n5s(5, n1, n3, n7, n9, s5);
smallOrient s28n46s(4, n2, n8, s4, s6, s5);
smallOrient s5n1379s(5, s1, s3, s7, s9, n5);
smallOrient s46n28s(4, n4, n6, s2, s8, n5);

/*------------------------------------------------------------------------------------*/
/* In setup, we do the following tasks: set up the PWM channel, set the LED and button
 * pins, set up the interrupt, and initialize all
 * the objects.  */
void setup() {
  //PWM setup
  ledcSetup(0, systemFreq, sysResolution);
  ledcAttachPin(23, 0);
  ledcWrite(0, systemLowDutyCycle);
  ledcSetup(1, systemFreq, sysResolution);
  ledcAttachPin(22, 1);
  ledcWrite(1, systemHighDutyCycle);

  //LED setup
  //TO DO
  
  //Button setup
  //TO DO
  
  //Attatch interrupt (this must be after stopStirring is initialized)
  //TO DO

}   //End setup

/*====================================================================================*/
void loop() {
/* When stopStirring is set to 0 by a button press, we entering the stirring function,
 * found inside the following if function. It is separated by large and small stirring
 * which have almost the same implementation. Every certain amount of time, set by
 * currentInt, we change the state of the device by sending a stateUpdate to each
 * object and incrementing to the next state. At a different interval, set by
 * systemCheckTime, the speed of the device is changed. The speed will be changed every
 * interval until the current period matches the target. When the stopStirring
 * interrupt happens, stopStirring is set to 1, and the function exits the while. */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  if(stopStirring == 0) {
    //Reseting all variables
    currentPer = systemSP;
    currentSN = 0;
    if(smallMode == 0) {
      currentInt = currentPer / sysLarNumStates;
      ledcWrite(1, systemHighDutyCycle);
    }
    else {
      currentInt = currentPer / sysSmlNumStates;
      ledcWrite(1, systemLowDutyCycle);
    }

    //Large stirring
    while((stopStirring == 0) && (smallMode == 0)) {
      //Stirring function
      currentTime = micros();
      if(currentTime - prevTimeState >= currentInt) {
        prevTimeState = currentTime;
        switch(currentSN) {
          case 0:   l3n.stateUpdate(-2);
                    currentSN = 1;  break;
          case 1:   l9n.stateUpdate(1);
                    currentSN = 2;  break;
          case 2:   l8n.stateUpdate(2);
                    currentSN = 3;  break;
          case 3:   l6n.stateUpdate(1);
                    currentSN = 4;  break;
          case 4:   l9n.stateUpdate(2);
                    currentSN = 5;  break;
          case 5:   l3n.stateUpdate(1);
                    currentSN = 6;  break;
          case 6:   l6n.stateUpdate(2);
                    currentSN = 7;  break;
          case 7:   l8n.stateUpdate(-1);
                    currentSN = 8;  break;
          case 8:   l3n.stateUpdate(2);
                    currentSN = 9;  break;
          case 9:   l9n.stateUpdate(-1);
                    currentSN = 10; break;
          case 10:  l8n.stateUpdate(-2);
                    currentSN = 11; break;
          case 11:  l6n.stateUpdate(-1);
                    currentSN = 12; break;
          case 12:  l9n.stateUpdate(-2);
                    currentSN = 13; break;
          case 13:  l3n.stateUpdate(-1);
                    currentSN = 14; break;
          case 14:  l6n.stateUpdate(-2);
                    currentSN = 15; break;
          case 15:  l8n.stateUpdate(1);
                    currentSN = 0;  break;
          default:  currentSN = 0;
        }   //End state switch
      }   //End state change if
      //Speed change function
      else if((currentTime - prevTimeCheck >= systemCheckTime) &&
              (currentSN == 0)) {
        prevTimeCheck = currentTime;
        periodChange = findPeriodChange(currentPer, currentTar);
        currentPer += periodChange;
        currentInt = currentPer / sysLarNumStates;        
      }   //End speed change if
    }   //End large stirring while
    
    //Small stirring
    while((stopStirring == 0) && (smallMode == 1)) {
      //Stirring function
      currentTime = micros();
      if(currentTime - prevTimeState >= currentInt) {
        prevTimeState = currentTime;
        switch(currentSN) {
          case 0: s1379N5S.stateUpdate(1);
                  s46N28S.stateUpdate(0);
                  currentSN = 1;  break;
          case 1: s28N46S.stateUpdate(1);
                  s1379N5S.stateUpdate(0);
                  currentSN = 2;  break;
          case 2: s5N1379S.stateUpdate(1);
                  s28N46S.stateUpdate(0);
                  currentSN = 3;  break;
          case 3: s46N28S.stateUpdate(1);
                  s5N1379S.stateUpdate(0);
                  currentSN = 0;  break;
        }   //End state switch
      }   //End state change if
      //Speed change function
      else if((currentTime - prevTimeCheck >= systemCheckTime) &&
              (currentSN == 0)) {
        prevTimeCheck = currentTime;
        periodChange = findPeriodChange(currentPer, currentTar);
        currentPer += periodChange;
        currentInt = currentPer / sysSmlNumStates;        
      }   //End speed change if
    }   //End small stirring while
    
    //Stirring exit
    //TO DO
  }   //End stopStirring if
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
}   //End loop

/*====================================================================================*/
/* The findPeriodChange function finds how much the period is supposed to change. This
 * is meant to be a percentage change of the current period, set by systemPercent. If
 * this change amount would be more than the difference the target period and the
 * current period, the function will return that difference. */
long findPeriodChange(long inCurPer, long inTarPer) {
  long tempVal;
  long returnVal = (long)((float)inCurPer * systemPercent);
  if(inCurPer > inTarPer) {
    tempVal = inCurPer - inTarPer;
    if(tempVal < returnVal) {
      returnVal = -tempVal;
      return returnVal;
    }
    else {
      returnVal = -returnVal;
      return returnVal;
    }
  }
  else if(inCurPer < inTarPer) {
    tempVal = inTarPer - inCurPer;
    if(tempVal < returnVal) {
      return tempVal;
    }
    else {
      return returnVal;
    }
  }
  else {
    returnVal = 0;
    return returnVal;
  }
}   //End findNumSteps function

/*------------------------------------------------------------------------------------*/
/* The stopInterrupt function simply sets stopStirring to 1, to exit the stirring while
 * loops. Compliant with the Arduino implementation of interrupts, this function must
 * return void and take no parameters. */
void stopInterrupt() {
  stopStirring = 1;
}   //End stopInterrupt function
