#include <Wire.h>
#include "Adafruit_MCP23017.h"

//Initialize slave instances
Adafruit_MCP23017 mcp14;
Adafruit_MCP23017 mcp58;

/*------------------------------------------------------------------------------------*/
//Testing variables
const long testSta = 200;     //starting period in ms
const long testTar = 40;      //target period in ms
const float testPer = 0.01;   //percent change
const float testChe = 1;       //check time in s
const int testNum = 16;       //number of states
const float testLDC = 0.5;    //percent LDC
const float testHDC = 0.5;    //percent HDC

/*------------------------------------------------------------------------------------*/
//Initialize system variables
const int systemFreq = 50000;           //Frequency of the PWM in Hz
const int sysResolution = 8;            //Number of bits for PWM channel
const long systemLowDutyCycle           //Low duty cycle value, an integer between
  = (long)((testLDC*256)-1);              //0 and 2^sysResolution
const long systemHighDutyCycle          //High duty cycle value
  = (long)((testHDC*256)-1);
const float systemPercent = testPer;    //Percentage change in the period
const long systemSP = testSta*1000;     //Default starting period in us
const long systemTP = testTar*1000;     //Default target period in us
const long systemCheckTime              //Default time between speed checks in us
  = (long)(testChe*1000000);
const int sysLarNumStates = testNum;    //Number of states for large stirring
const int sysSmlNumStates = 4;          //Number of states for small stirring

/*------------------------------------------------------------------------------------*/
//Capacitive touch pads
const int ctp1 = 34;
const int ctp2 = 35;
const int ctp3 = 32;
const int ctp4 = 33;
const int ctp5 = 25;

//Coil control
const int u1an = 8; const int u1as = 9;
const int u1bn = 10; const int u1bs = 11;

const int u2an = 12; const int u2as = 13;
const int u2bn = 14; const int u2bs = 15;

const int u3an = 0; const int u3as = 1;
const int u3bn = 2; const int u3bs = 3;

const int u4an = 4; const int u4as = 5;
const int u4bn = 6; const int u4bs = 7;

const int u5an = 8; const int u5as = 9;
const int u5bn = 10; const int u5bs = 11;

const int u6an = 12; const int u6as = 13;
const int u6bn = 14; const int u6bs = 15;

const int u7an = 0; const int u7as = 1;
const int u7bn = 2; const int u7bs = 3;

const int u8an = 4; const int u8as = 5;
const int u8bn = 6; const int u8bs = 7;

const int u9an = 2; const int u9as = 15;
const int u9bn = 0; const int u9bs = 4;

/*------------------------------------------------------------------------------------*/
/*
//Coil pin numbers
/* 7 8 9
 * 4 5 6
 * 1 2 3 */
const int n1 = 21, s1 = 19;
const int n2 = 33, s2 = 32;
const int n3 = 18, s3 = 5;
const int n4 = 27, s4 = 14;
const int n5 = 2, s5 = 15;
const int n6 = 25, s6 = 26;
const int n7 = 16, s7 = 17;
const int n8 = 13, s8 = 12;
const int n9 = 4, s9 = 0;
 */
 
/*------------------------------------------------------------------------------------*/
//Display pins
/*  a
 * f b
 *  g
 * e c
 *  d  */
const int dispA = 26;
const int dispB = 27;
const int dispC = 14;
const int dispD = 12;
const int dispE = 13;
const int dispF = 23;
const int dispG = 19;
const int dispOne = 18;
const int dispZero = 5;

/*------------------------------------------------------------------------------------*/
//Pin setup
//Slave setup
mcp14.begin(0);   //Default address
mcp14.begin(1);
int count = 0;
for(count < 16) {
  mcp14.pinMode(count, OUTPUT);
  mcp58.pinMode(count, OUTPUT);
  count++;
}

//Esp32 setup
pinMode(ctp1, INPUT);   //Touchpad setup
pinMode(ctp2, INPUT);
pinMode(ctp3, INPUT);
pinMode(ctp4, INPUT);
pinMode(ctp5, INPUT);
pinMode(dispA, OUTPUT);   pinMode(dispB, OUTPUT);   //Display setup
pinMode(dispC, OUTPUT);   pinMode(dispD, OUTPUT);
pinMode(dispE, OUTPUT);   pinMode(dispF, OUTPUT);
pinMode(dispG, OUTPUT);
pinMode(dispOne, OUTPUT);
pinMode(dispZero, OUTPUT);
pinMode(u9bs, OUTPUT);   //Coil 9 setup
pinMode(u9bn, OUTPUT);
pinMode(u9an, OUTPUT);
pinMode(u9as, OUTPUT);
//LED SETUP TO DO

/*------------------------------------------------------------------------------------*/
//Function declarations
void largeUpdate(int inCoil, int inState);
void smallUpdate(int inCoils, int inState);
long findPeriodChange(long inCurPer, long inTarPer);
void stopInterrupt();
int timeDifference(unsigned long inTime, unsigned long inPrev, long inDiff);
void setDisplay(int inNum);
int findRPM(long inNum);

/*------------------------------------------------------------------------------------*/
/* The large orient class is meant for stirring large beakers. It will turn on 2 coils,
 * which should be different polarity. Since the pin mode function is in this class,
 * it must be initialized before the small orient class. The state update function
 * will either turn off or turn on the coils. This orient is for coils 1 to 4.*/
class largeOrient14 {
  int coilPin1n;
  int coilPin1s;
  int coilPin2n;
  int coilPin2s;

  public:
  largeOrient14(int pin1, int pin2, int pin3, int pin4) {
    coilPin1n = pin1;
    coilPin1s = pin2;
    coilPin2n = pin3;
    coilPin2s = pin4;
    mcp14.digitalWrite(coilPin1n, LOW);
    mcp14.digitalWrite(coilPin1s, LOW);
    mcp14.digitalWrite(coilPin2n, LOW);
    mcp14.digitalWrite(coilPin2s, LOW);
  }   //End largeOrient14 constructor 

  //1 = coil 1 north, 2 = coil 1 off, -1 = coil 2 north, -2 = coil 2 off, 0 = both off
  void stateUpdate(int inState) {
    switch(inState) {
      case 1:   mcp14.digitalWrite(coilPin1n, HIGH);
                mcp14.digitalWrite(coilPin2s, HIGH);    break;
      case 2:   mcp14.digitalWrite(coilPin1n, LOW);
                mcp14.digitalWrite(coilPin2s, LOW);     break;
      case -1:  mcp14.digitalWrite(coilPin2n, HIGH);
                mcp14.digitalWrite(coilPin1s, HIGH);    break;
      case -2:  mcp14.digitalWrite(coilPin2n, LOW);
                mcp14.digitalWrite(coilPin1s, LOW);     break;
      default:  mcp14.digitalWrite(coilPin1n, LOW);
                mcp14.digitalWrite(coilPin1s, LOW);
                mcp14.digitalWrite(coilPin2n, LOW);
                mcp14.digitalWrite(coilPin2s, LOW);
    }   //End switch
  }   //End stateUpdate function
};    //End largeOrient14 class

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* This large orient is for coils 5 to 8.*/
class largeOrient58 {
  int coilPin1n;
  int coilPin1s;
  int coilPin2n;
  int coilPin2s;

  public:
  largeOrient58(int pin1, int pin2, int pin3, int pin4) {
    coilPin1n = pin1;
    coilPin1s = pin2;
    coilPin2n = pin3;
    coilPin2s = pin4;
    mcp58.digitalWrite(coilPin1n, LOW);
    mcp58.digitalWrite(coilPin1s, LOW);
    mcp58.digitalWrite(coilPin2n, LOW);
    mcp58.digitalWrite(coilPin2s, LOW);
  }   //End largeOrient58 constructor 

  //1 = coil 1 north, 2 = coil 1 off, -1 = coil 2 north, -2 = coil 2 off, 0 = both off
  void stateUpdate(int inState) {
    switch(inState) {
      case 1:   mcp58.digitalWrite(coilPin1n, HIGH);
                mcp58.digitalWrite(coilPin2s, HIGH);    break;
      case 2:   mcp58.digitalWrite(coilPin1n, LOW);
                mcp58.digitalWrite(coilPin2s, LOW);     break;
      case -1:  mcp58.digitalWrite(coilPin2n, HIGH);
                mcp58.digitalWrite(coilPin1s, HIGH);    break;
      case -2:  mcp58.digitalWrite(coilPin2n, LOW);
                mcp58.digitalWrite(coilPin1s, LOW);     break;
      default:  mcp58.digitalWrite(coilPin1n, LOW);
                mcp58.digitalWrite(coilPin1s, LOW);
                mcp58.digitalWrite(coilPin2n, LOW);
                mcp58.digitalWrite(coilPin2s, LOW);
    }   //End switch
  }   //End stateUpdate function
};    //End largeOrient58 class

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* This large orient is for coil 9.*/
class largeOrient9 {
  int coilPin1n;
  int coilPin1s;
  int coilPin2n;
  int coilPin2s;

  public:
  largeOrient9(int pin1, int pin2, int pin3, int pin4) {
    coilPin1n = pin1;
    coilPin1s = pin2;
    coilPin2n = pin3;
    coilPin2s = pin4;
    mcp14.digitalWrite(coilPin1n, LOW);
    mcp14.digitalWrite(coilPin1s, LOW);
    mcp14.digitalWrite(coilPin2n, LOW);
    mcp14.digitalWrite(coilPin2s, LOW);
  }   //End largeOrient9 constructor 

  //1 = coil 1 north, 2 = coil 1 off, -1 = coil 2 north, -2 = coil 2 off, 0 = both off
  void stateUpdate(int inState) {
    switch(inState) {
      case 1:   digitalWrite(coilPin1n, HIGH);
                digitalWrite(coilPin2s, HIGH);    break;
      case 2:   digitalWrite(coilPin1n, LOW);
                digitalWrite(coilPin2s, LOW);     break;
      case -1:  digitalWrite(coilPin2n, HIGH);
                digitalWrite(coilPin1s, HIGH);    break;
      case -2:  digitalWrite(coilPin2n, LOW);
                digitalWrite(coilPin1s, LOW);     break;
      default:  digitalWrite(coilPin1n, LOW);
                digitalWrite(coilPin1s, LOW);
                digitalWrite(coilPin2n, LOW);
                digitalWrite(coilPin2s, LOW);
    }   //End switch
  }   //End stateUpdate function
};    //End largeOrient9 class

/*------------------------------------------------------------------------------------*/
/* The small orient class is meant for stirring the small vials. It will turn on either
 * 4 or 5 coils, which is decided when initializing the object. When meant for 5 coils,
 * pin5 should be used for the center coil. Since the center pin is not used for large
 * stirring, the pin mode function for the center coil is here. */
class smallOrient {
  int numCoils;
  int coilPin1, coilPin2, coilPin3, coilPin4, coilPin5;

  public:
  smallOrient(int inNumber, int pin1, int pin2, int pin3, int pin4, int pin5) {
    numCoils = inNumber;
    coilPin1 = pin1;
    coilPin2 = pin2;
    coilPin3 = pin3;
    coilPin4 = pin4;
    if(numCoils == 5) {
      coilPin5 = pin5;
      pinMode(coilPin5, OUTPUT);
      digitalWrite(coilPin5, LOW);
    }
    else
      coilPin5 = 0;
  }   //End largeOrient constructor 

  void stateUpdate(int inState) {
    if(inState == 0) {
      digitalWrite(coilPin1, LOW);
      digitalWrite(coilPin2, LOW);
      digitalWrite(coilPin3, LOW);
      digitalWrite(coilPin4, LOW);
      if(numCoils == 5)
        digitalWrite(coilPin5, LOW);
    }
    else {
      digitalWrite(coilPin1, HIGH);
      digitalWrite(coilPin2, HIGH);
      digitalWrite(coilPin3, HIGH);
      digitalWrite(coilPin4, HIGH);
      if(numCoils == 5)
        digitalWrite(coilPin5, HIGH);
    }
  }   //End stateUpdate function
};    //End smallOrient class

/*------------------------------------------------------------------------------------*/
//Initialize program variables and objects

//State Variables
volatile int stopStirring = 0;
volatile int atSpeed = 0;
volatile int currentSN = 0;
volatile int smallMode = 0;

//Time variables
volatile unsigned long currentTime = 0;
volatile unsigned long prevTimeState = 0;
volatile unsigned long prevTimeCheck = 0;

//Period variables
volatile long currentPer = systemSP;
volatile long currentTar = systemTP;
volatile long currentInt = currentPer / sysLarNumStates;
volatile long periodChange = 0;

/* Remember that largeOrient sets the pin mode, so they must be initialized first.
 * All largeOrients must be initialized, even if they won't be used. */
//Initialize largeOrient instances
largeOrient14 la8n(n8, s8, n2, n2);
largeOrient14 la9n(n9, s9, n1, s1);
largeOrient la6n(n6, s6, n4, s4);
largeOrient la3n(n3, s3, n7, s7);

//Initialize smallOrient instances
smallOrient s1379n5s(5, n1, n3, n7, n9, s5);
smallOrient s28n46s(4, n2, n8, s4, s6, s5);
smallOrient s5n1379s(5, s1, s3, s7, s9, n5);
smallOrient s46n28s(4, n4, n6, s2, s8, n5);

/*------------------------------------------------------------------------------------*/
/* In setup, we do the following tasks: set up the PWM channel, set the LED and button
 * pins, set up the interrupt, and initialize all
 * the objects.  */
void setup() {
  //PWM setup
  ledcSetup(0, systemFreq, sysResolution);
  ledcAttachPin(23, 0);
  ledcWrite(0, systemLowDutyCycle);
  ledcSetup(1, systemFreq, sysResolution);
  ledcAttachPin(22, 1);
  ledcWrite(1, systemHighDutyCycle);
  
  
  
  //LED setup
  //TO DO
  
  //Display setup
  
  setDisplay(findRPM(currentTar));
  
  //Button setup
  //TO DO
  
  //Attatch interrupt (this must be after stopStirring is initialized)
  //TO DO

}   //End setup

/*====================================================================================*/
void loop() {
/* When stopStirring is set to 0 by a button press, we entering the stirring function,
 * found inside the following if function. It is separated by large and small stirring
 * which have almost the same implementation. Every certain amount of time, set by
 * currentInt, we change the state of the device by sending a stateUpdate to each
 * object and incrementing to the next state. At a different interval, set by
 * systemCheckTime, the speed of the device is changed. The speed will be changed every
 * interval until the current period matches the target. When the stopStirring
 * interrupt happens, stopStirring is set to 1, and the function exits the while. */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  if(stopStirring == 0) {
    //Reseting all variables
    currentPer = systemSP;
    currentSN = 0;
    if(smallMode == 0) {
      currentInt = currentPer / sysLarNumStates;
      ledcWrite(1, systemHighDutyCycle);
    }
    else {
      currentInt = currentPer / sysSmlNumStates;
      ledcWrite(1, systemLowDutyCycle);
    }

    //Large stirring
    while((stopStirring == 0) && (smallMode == 0)) {
      //Stirring function
      currentTime = micros();
      if(timeDifference(currentTime, prevTimeState, currentInt)) {
        prevTimeState = currentTime;
        switch(currentSN) {
          case 0:   l3n.stateUpdate(-2);
                    currentSN = 1;  break;
          case 1:   l9n.stateUpdate(1);
                    currentSN = 2;  break;
          case 2:   l8n.stateUpdate(2);
                    currentSN = 3;  break;
          case 3:   l6n.stateUpdate(1);
                    currentSN = 4;  break;
          case 4:   l9n.stateUpdate(2);
                    currentSN = 5;  break;
          case 5:   l3n.stateUpdate(1);
                    currentSN = 6;  break;
          case 6:   l6n.stateUpdate(2);
                    currentSN = 7;  break;
          case 7:   l8n.stateUpdate(-1);
                    currentSN = 8;  break;
          case 8:   l3n.stateUpdate(2);
                    currentSN = 9;  break;
          case 9:   l9n.stateUpdate(-1);
                    currentSN = 10; break;
          case 10:  l8n.stateUpdate(-2);
                    currentSN = 11; break;
          case 11:  l6n.stateUpdate(-1);
                    currentSN = 12; break;
          case 12:  l9n.stateUpdate(-2);
                    currentSN = 13; break;
          case 13:  l3n.stateUpdate(-1);
                    currentSN = 14; break;
          case 14:  l6n.stateUpdate(-2);
                    currentSN = 15; break;
          case 15:  l8n.stateUpdate(1);
                    currentSN = 0;  break;
          default:  currentSN = 0;
        }   //End state switch
      }   //End state change if
      //Speed change function
      else if((timeDifference(currentTime, prevTimeCheck, systemCheckTime)) &&
              (currentSN == 0)) {
        prevTimeCheck = currentTime;
        periodChange = findPeriodChange(currentPer, currentTar);
        currentPer += periodChange;
        currentInt = currentPer / sysLarNumStates;        
      }   //End speed change if
    }   //End large stirring while
    
    //Small stirring
    while((stopStirring == 0) && (smallMode == 1)) {
      //Stirring function
      currentTime = micros();
      if(timeDifference(currentTime, prevTimeState, currentInt)) {
        prevTimeState = currentTime;
        switch(currentSN) {
          case 0: s1379n5s.stateUpdate(1);
                  s46n28s.stateUpdate(0);
                  currentSN = 1;  break;
          case 1: s28n46s.stateUpdate(1);
                  s1379n5s.stateUpdate(0);
                  currentSN = 2;  break;
          case 2: s5n1379s.stateUpdate(1);
                  s28n46s.stateUpdate(0);
                  currentSN = 3;  break;
          case 3: s46n28s.stateUpdate(1);
                  s5n1379s.stateUpdate(0);
                  currentSN = 0;  break;
        }   //End state switch
      }   //End state change if
      //Speed change function
      else if((timeDifference(currentTime, prevTimeCheck, systemCheckTime)) &&
              (currentSN == 0)) {
        prevTimeCheck = currentTime;
        periodChange = findPeriodChange(currentPer, currentTar);
        currentPer += periodChange;
        currentInt = currentPer / sysSmlNumStates;        
      }   //End speed change if
    }   //End small stirring while
    
    //Stirring exit
    //TO DO
  }   //End stopStirring if
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
}   //End loop

/*====================================================================================*/
/* The largeUpdate function turns the specified coils on or off. The variable inCoil
 * is the coilset which should turn on. For inState: 1=north, 2=south, 0=off */
void coilUpdate(int inCoil, int inState) {
  switch(inCoil) {
    case 1: switch(inState) {
              case 1: mcp14.digitalWrite(u1as, LOW);
                      mcp14.digitalWrite(u1bs, LOW);
                      mcp14.digitalWrite(u1an, HIGH);
                      mcp14.digitalWrite(u1bn, HIGH);   break;
              case 2: mcp14.digitalWrite(u1an, LOW);
                      mcp14.digitalWrite(u1bn, LOW);
                      mcp14.digitalWrite(u1as, HIGH);
                      mcp14.digitalWrite(u1bs, HIGH);   break;
              case 0: mcp14.digitalWrite(u1as, LOW);
                      mcp14.digitalWrite(u1bs, LOW);
                      mcp14.digitalWrite(u1an, LOW);
                      mcp14.digitalWrite(u1bn, LOW);
            } break;
    case 2: switch(inState) {
              case 1: mcp14.digitalWrite(u2as, LOW);
                      mcp14.digitalWrite(u2bs, LOW);
                      mcp14.digitalWrite(u2an, HIGH);
                      mcp14.digitalWrite(u2bn, HIGH);   break;
              case 2: mcp14.digitalWrite(u2an, LOW);
                      mcp14.digitalWrite(u2bn, LOW);
                      mcp14.digitalWrite(u2as, HIGH);
                      mcp14.digitalWrite(u2bs, HIGH);   break;
              case 0: mcp14.digitalWrite(u2as, LOW);
                      mcp14.digitalWrite(u2bs, LOW);
                      mcp14.digitalWrite(u2an, LOW);
                      mcp14.digitalWrite(u2bn, LOW);
            } break;
    case 3: switch(inState) {
              case 1: mcp14.digitalWrite(u3as, LOW);
                      mcp14.digitalWrite(u3bs, LOW);
                      mcp14.digitalWrite(u3an, HIGH);
                      mcp14.digitalWrite(u3bn, HIGH);   break;
              case 2: mcp14.digitalWrite(u3an, LOW);
                      mcp14.digitalWrite(u3bn, LOW);
                      mcp14.digitalWrite(u3as, HIGH);
                      mcp14.digitalWrite(u3bs, HIGH);   break;
              case 0: mcp14.digitalWrite(u3as, LOW);
                      mcp14.digitalWrite(u3bs, LOW);
                      mcp14.digitalWrite(u3an, LOW);
                      mcp14.digitalWrite(u3bn, LOW);
            } break;
    case 4: switch(inState) {
              case 1: mcp14.digitalWrite(u4as, LOW);
                      mcp14.digitalWrite(u4bs, LOW);
                      mcp14.digitalWrite(u4an, HIGH);
                      mcp14.digitalWrite(u4bn, HIGH);   break;
              case 2: mcp14.digitalWrite(u4an, LOW);
                      mcp14.digitalWrite(u4bn, LOW);
                      mcp14.digitalWrite(u4as, HIGH);
                      mcp14.digitalWrite(u4bs, HIGH);   break;
              case 0: mcp14.digitalWrite(u4as, LOW);
                      mcp14.digitalWrite(u4bs, LOW);
                      mcp14.digitalWrite(u4an, LOW);
                      mcp14.digitalWrite(u4bn, LOW);
            } break;
    case 5: switch(inState) {
              case 1: mcp58.digitalWrite(u5as, LOW);
                      mcp58.digitalWrite(u5bs, LOW);
                      mcp58.digitalWrite(u5an, HIGH);
                      mcp58.digitalWrite(u5bn, HIGH);   break;
              case 2: mcp58.digitalWrite(u5an, LOW);
                      mcp58.digitalWrite(u5bn, LOW);
                      mcp58.digitalWrite(u5as, HIGH);
                      mcp58.digitalWrite(u5bs, HIGH);   break;
              case 0: mcp58.digitalWrite(u5as, LOW);
                      mcp58.digitalWrite(u5bs, LOW);
                      mcp58.digitalWrite(u5an, LOW);
                      mcp58.digitalWrite(u5bn, LOW);
            } break;
    case 6: switch(inState) {
              case 1: mcp58.digitalWrite(u6as, LOW);
                      mcp58.digitalWrite(u6bs, LOW);
                      mcp58.digitalWrite(u6an, HIGH);
                      mcp58.digitalWrite(u6bn, HIGH);   break;
              case 2: mcp58.digitalWrite(u6an, LOW);
                      mcp58.digitalWrite(u6bn, LOW);
                      mcp58.digitalWrite(u6as, HIGH);
                      mcp58.digitalWrite(u6bs, HIGH);   break;
              case 0: mcp58.digitalWrite(u6as, LOW);
                      mcp58.digitalWrite(u6bs, LOW);
                      mcp58.digitalWrite(u6an, LOW);
                      mcp58.digitalWrite(u6bn, LOW);
            } break;
    case 7: switch(inState) {
              case 1: mcp58.digitalWrite(u7as, LOW);
                      mcp58.digitalWrite(u7bs, LOW);
                      mcp58.digitalWrite(u7an, HIGH);
                      mcp58.digitalWrite(u7bn, HIGH);   break;
              case 2: mcp58.digitalWrite(u7an, LOW);
                      mcp58.digitalWrite(u7bn, LOW);
                      mcp58.digitalWrite(u7as, HIGH);
                      mcp58.digitalWrite(u7bs, HIGH);   break;
              case 0: mcp58.digitalWrite(u7as, LOW);
                      mcp58.digitalWrite(u7bs, LOW);
                      mcp58.digitalWrite(u7an, LOW);
                      mcp58.digitalWrite(u7bn, LOW);
            } break;
    case 8: switch(inState) {
              case 1: mcp58.digitalWrite(u8as, LOW);
                      mcp58.digitalWrite(u8bs, LOW);
                      mcp58.digitalWrite(u8an, HIGH);
                      mcp58.digitalWrite(u8bn, HIGH);   break;
              case 2: mcp58.digitalWrite(u8an, LOW);
                      mcp58.digitalWrite(u8bn, LOW);
                      mcp58.digitalWrite(u8as, HIGH);
                      mcp58.digitalWrite(u8bs, HIGH);   break;
              case 0: mcp58.digitalWrite(u8as, LOW);
                      mcp58.digitalWrite(u8bs, LOW);
                      mcp58.digitalWrite(u8an, LOW);
                      mcp58.digitalWrite(u8bn, LOW);
            } break;
  }   //End switch
}   //End largeUpdate function

/*------------------------------------------------------------------------------------*/
/* The findPeriodChange function finds how much the period is supposed to change. This
 * is meant to be a percentage change of the current period, set by systemPercent. If
 * this change amount would be more than the difference the target period and the
 * current period, the function will return that difference. */
long findPeriodChange(long inCurPer, long inTarPer) {
  long tempVal;
  long returnVal = (long)((float)inCurPer * systemPercent);
  if(inCurPer > inTarPer) {
    tempVal = inCurPer - inTarPer;
    if(tempVal < returnVal) {
      returnVal = -tempVal;
      return returnVal; }
    else {
      returnVal = -returnVal;
      return returnVal; }
  }
  else if(inCurPer < inTarPer) {
    tempVal = inTarPer - inCurPer;
    if(tempVal < returnVal) {
      return tempVal; }
    else {
      return returnVal; }
  }
  else {
    returnVal = 0;
    return returnVal;
  }
}   //End findNumSteps function

/*------------------------------------------------------------------------------------*/
/* The stopInterrupt function simply sets stopStirring to 1, to exit the stirring while
 * loops. Compliant with the Arduino implementation of interrupts, this function must
 * return void and take no parameters. */
void stopInterrupt() {
  stopStirring = 1;
}   //End stopInterrupt function

/*------------------------------------------------------------------------------------*/
/* The timeDifference function is the check condition to see if the state is switching
 * or if the device needs to increase in speed. The first condition in the if function
 * is the main one: to see if difference from the last time checked and the current
 * time is larger than a specific amount. The second condition is meant to handle when
 * the micros() function resets to zero because the counting register reached the
 * largest value posible (bit overflow). */
int timeDifference(unsigned long inTime, unsigned long inPrev, long inDiff) {
  if(inTime - inPrev >= inDiff)
    return 1;
  else if((inTime >= (inDiff / 2)) && (inPrev > 100000000) && (inTime < 10000000))
    return 1;
  else
    return 0;
}   //End timeDifference function

/*------------------------------------------------------------------------------------*/
/* The setDisplay function sets the number to be displayed. The number will always be
 * a multiple of 100, for the display sets the tens and ones place to one. */
void setDisplay(int inNum) {
  int temp = (inNum - 1000) / 100;
  digitalWrite(dispZero, HIGH);
  if(inNum >= 1000)
    digitalWrite(dispOne, HIGH);
  else
    digitalWrite(dispOne, LOW);
    
  switch(temp) {
    case 2: case 3: case 5: case 6:
    case 7: case 8: case 9: case 0:
      digitalWrite(dispA, HIGH);  break;
    default:  digitalWrite(dispA, LOW); break;
  }   //End a switch
  
  switch(temp) {
    case 1: case 2: case 3: case 4:
    case 7: case 8: case 9: case 0:
      digitalWrite(dispB, HIGH);  break;
    default:  digitalWrite(dispB, LOW); break;
  }   //End b switch
  
  switch(temp) {
    case 1: case 3: case 4: case 5:
    case 6: case 7: case 8: case 9:
    case 0:
      digitalWrite(dispC, HIGH);  break;
    default:  digitalWrite(dispC, LOW); break;
  }   //End c switch
  
  switch(temp) {
    case 2: case 3: case 5: case 6:
    case 8: case 0:
      digitalWrite(dispD, HIGH);  break;
    default:  digitalWrite(dispD, LOW); break;
  }   //End d switch
  
  switch(temp) {
    case 2: case 6: case 8: case 0:
      digitalWrite(dispE, HIGH);  break;
    default:  digitalWrite(dispE, LOW); break;
  }   //End e switch
  
  switch(temp) {
    case 4: case 5: case 6: case 8:
    case 9: case 0:
      digitalWrite(dispF, HIGH);  break;
    default:  digitalWrite(dispF, LOW); break;
  }   //End f switch
  
  switch(temp) {
    case 2: case 3: case 4: case 5:
    case 6: case 8: case 9:
      digitalWrite(dispG, HIGH);  break;
    default:  digitalWrite(dispG, LOW); break;
  }   //End g switch
}   //End setDisplay function

/*------------------------------------------------------------------------------------*/
/* The findRPM function takes in a period in us and returns the corresponding rpm. If
 * the period is less than or equal to 30000, the rpm is 2000 or higher. Thus this
 * function returns 1999, which is the largest number that can be on the display. */
int findRPM(long inNum) {
  int returnVal;
  if(inNum <= 30000)
    returnVal = 1999;
  else
    returnVal = (int)((60*1000*1000)/inNum);
  return returnVal;
}   //End findRPM function
