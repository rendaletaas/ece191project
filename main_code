//Testing variables
const long testSta = 350;     //starting period in ms
const long testTar = 40;      //target period in ms
const float testPer = 0.009;   //percent change
const float testChe = 1.3;       //check time in s
const int testNum = 8;       //number of states
const float testLDC = 0.65;    //percent LDC
const float testHDC = 0.3;    //percent HDC

/*------------------------------------------------------------------------------------*/
//Initialize system variables
const int systemFreq = 50000;           //Frequency of the PWM in Hz
const int sysResolution = 8;            //Number of bits for PWM channel
const long systemLowDutyCycle           //Low duty cycle value, an integer between
  = (long)((testLDC*256)-1);              //0 and 2^sysResolution
const long systemHighDutyCycle          //High duty cycle value
  = (long)((testHDC*256)-1);
const float systemPercent = testPer;    //Percentage change in the period
const long systemSP = testSta*1000;     //Default starting period in us
const long systemTP = testTar*1000;     //Default target period in us
const long systemCheckTime              //Default time between speed checks in us
  = (long)(testChe*1000000);
const int sysLarNumStates = testNum;    //Number of states for large stirring
const int sysSmlNumStates = 4;          //Number of states for small stirring
/*
//Initialize system variables
const int systemFreq = 1000;         //Frequency of the PWM in Hz
const int sysResolution = 8;          //Number of bits for PWM channel
const long systemLowDutyCycle = 100;  //Low duty cycle value, an integer between
                                      //0 and 2^sysResolution
const long systemHighDutyCycle = 150; //High duty cycle value
const float systemPercent = 0.01;     //Percentage change in the period
const long systemSP = 720000;            //Default starting period in ms
const long systemTP = 40000;            //Default target period in ms
const long systemCheckTime = 1500000;    //Default time between speed checks in ms
const int sysLarNumStates = 8;        //Number of states for large stirring
const int sysSmlNumStates = 4;        //Number of states for small stirring
*/
/*------------------------------------------------------------------------------------*/
//Coil pin numbers
/* 7 8 9
 * 4 5 6
 * 1 2 3 */
const int n1 = 21, s1 = 19;
const int n2 = 33, s2 = 32;
const int n3 = 18, s3 = 5;
const int n4 = 27, s4 = 14;
const int n5 = 2, s5 = 15;
const int n6 = 25, s6 = 26;
const int n7 = 16, s7 = 17;
const int n8 = 13, s8 = 12;
const int n9 = 4, s9 = 0;
 
/*------------------------------------------------------------------------------------*/
//Function declarations
long findPeriodChange(long inCurPer, long inTarPer);
void stopInterrupt();

/*------------------------------------------------------------------------------------*/
/* The large orient class is meant for stirring large beakers. It will turn on 2 coils,
 * which should be different polarity. Since the pin mode function is in this class,
 * it must be initialized before the small orient class. The state update function
 * will either turn off or turn on the coils. */
class largeOrient {
  int coilPin1;
  int coilPin2;

  public:
  largeOrient(int pin1, int pin2) {
    coilPin1 = pin1;
    coilPin2 = pin2;
    pinMode(coilPin1, OUTPUT);
    pinMode(coilPin2, OUTPUT);
    digitalWrite(coilPin1, LOW);
    digitalWrite(coilPin2, LOW);
  }   //End largeOrient constructor 

  void stateUpdate(int inState) {
    if(inState == 0) {
      digitalWrite(coilPin1, LOW);
      digitalWrite(coilPin2, LOW);
    }
    else {
      digitalWrite(coilPin1, HIGH);
      digitalWrite(coilPin2, HIGH);
    }
  }   //End stateUpdate function
};    //End largeOrient class

/*------------------------------------------------------------------------------------*/
/* The small orient class is meant for stirring the small vials. It will turn on either
 * 4 or 5 coils, which is decided when initializing the object. When meant for 5 coils,
 * pin5 should be used for the center coil. Since the center pin is not used for large
 * stirring, the pin mode function for the center coil is here. */
class smallOrient {
  int numCoils;
  int coilPin1, coilPin2, coilPin3, coilPin4, coilPin5;

  public:
  smallOrient(int inNumber, int pin1, int pin2, int pin3, int pin4, int pin5) {
    numCoils = inNumber;
    coilPin1 = pin1;
    coilPin2 = pin2;
    coilPin3 = pin3;
    coilPin4 = pin4;
    if(numCoils == 5) {
      coilPin5 = pin5;
      pinMode(coilPin5, OUTPUT);
      digitalWrite(coilPin5, LOW);
    }
    else
      coilPin5 = 0;
  }   //End largeOrient constructor 

  void stateUpdate(int inState) {
    if(inState == 0) {
      digitalWrite(coilPin1, LOW);
      digitalWrite(coilPin2, LOW);
      digitalWrite(coilPin3, LOW);
      digitalWrite(coilPin4, LOW);
      if(numCoils == 5)
        digitalWrite(coilPin5, LOW);
    }
    else {
      digitalWrite(coilPin1, HIGH);
      digitalWrite(coilPin2, HIGH);
      digitalWrite(coilPin3, HIGH);
      digitalWrite(coilPin4, HIGH);
      if(numCoils == 5)
        digitalWrite(coilPin5, HIGH);
    }
  }   //End stateUpdate function
};    //End smallOrient class

/*------------------------------------------------------------------------------------*/
//Initialize program variables and objects

//State Variables
volatile int stopStirring = 0;
volatile int atSpeed = 0;
volatile int currentSN = 0;
volatile int smallMode = 0;

//Time variables
volatile unsigned long currentMillis = 0;
volatile unsigned long prevMlsState = 0;
volatile unsigned long prevMlsCheck = 0;

//Period variables
volatile long currentPer = systemSP;
volatile long currentTar = systemTP;
volatile long currentInt = currentPer / sysLarNumStates;
volatile long periodChange = 0;

/* Remember that largeOrient sets the pin mode, so they must be initialized first.
 * All largeOrients must be initialized, even if they won't be used. */
//Initialize largeOrient instances
largeOrient l8N2S(n8, s2);
largeOrient l9N1S(n9, s1);
largeOrient l6N4S(n6, s4);
largeOrient l3N7S(n3, s7);
largeOrient l2N8S(n2, s8);
largeOrient l1N9S(n1, s9);
largeOrient l4N6S(n4, s6);
largeOrient l7N3S(n7, s3);

//Initialize smallOrient instances
smallOrient s1379N5S(5, n1, n3, n7, n9, s5);
smallOrient s28N46S(4, n2, n8, s4, s6, s5);
smallOrient s5N1379S(5, s1, s3, s7, s9, n5);
smallOrient s46N28S(4, n4, n6, s2, s8, n5);

/*------------------------------------------------------------------------------------*/
/* In setup, we do the following tasks: set up the PWM channel, set the LED and button
 * pins, set up the interrupt, and initialize all
 * the objects.  */
void setup() {
  //PWM setup
  ledcSetup(0, systemFreq, sysResolution);
  ledcAttachPin(23, 0);
  ledcWrite(0, systemLowDutyCycle);
  ledcSetup(1, systemFreq, sysResolution);
  ledcAttachPin(22, 1);
  ledcWrite(1, systemHighDutyCycle);

  //LED setup
  //TO DO
  
  //Button setup
  //TO DO
  
  //Attatch interrupt (this must be after stopStirring is initialized)
  //TO DO

}   //End setup

/*====================================================================================*/
void loop() {
/* When stopStirring is set to 0 by a button press, we entering the stirring function,
 * found inside the following if function. It is separated by large and small stirring
 * which have almost the same implementation. Every certain amount of time, set by
 * currentInt, we change the state of the device by sending a stateUpdate to each
 * object and incrementing to the next state. At a different interval, set by
 * systemCheckTime, the speed of the device is changed. The speed will be changed every
 * interval until the current period matches the target. When the stopStirring
 * interrupt happens, stopStirring is set to 1, and the function exits the while. */
  if(stopStirring == 0) {
    //Reseting all variables
    currentSN = 0;
    currentPer = systemSP;
    if(smallMode == 0)
      currentInt = currentPer / sysLarNumStates;
    else
      currentInt = currentPer / sysSmlNumStates;
      
    //Large stirring
    while((stopStirring == 0) && (smallMode == 0)) {
      //Stirring function
      currentMillis = micros();
      if(currentMillis - prevMlsState >= currentInt) {
        prevMlsState = currentMillis;
        switch(currentSN) {
          case 0: l7N3S.stateUpdate(0);
                  l9N1S.stateUpdate(1);
                  currentSN = 1;  break;
          case 1: l8N2S.stateUpdate(0);
                  l6N4S.stateUpdate(1);
                  currentSN = 2;  break;
          case 2: l9N1S.stateUpdate(0);
                  l3N7S.stateUpdate(1);
                  currentSN = 3;  break;
          case 3: l6N4S.stateUpdate(0);
                  l2N8S.stateUpdate(1);
                  currentSN = 4;  break;
          case 4: l3N7S.stateUpdate(0);
                  l1N9S.stateUpdate(1);
                  currentSN = 5;  break;
          case 5: l2N8S.stateUpdate(0);
                  l4N6S.stateUpdate(1);
                  currentSN = 6;  break;
          case 6: l1N9S.stateUpdate(0);
                  l7N3S.stateUpdate(1);
                  currentSN = 7;  break;
          case 7: l4N6S.stateUpdate(0);
                  l8N2S.stateUpdate(1);
                  currentSN = 0;  break;
          default:currentSN = 0;
        }   //End state switch
      }   //End state change if
      
      //Speed change function
      else if((currentMillis - prevMlsCheck >= systemCheckTime) &&
              (currentSN == 0)) {
        prevMlsCheck = currentMillis;
        periodChange = findPeriodChange(currentPer, currentTar);
        currentPer += periodChange;
        currentInt = currentPer / sysLarNumStates;        
      }   //End speed change if
    }   //End large stirring while
    
    //Small stirring
    while((stopStirring == 0) && (smallMode == 1)) {
      //Stirring function
      currentMillis = millis();
      if(currentMillis - prevMlsState >= currentInt) {
        prevMlsState = currentMillis;
        switch(currentSN) {
          case 0: s1379N5S.stateUpdate(1);
                  s46N28S.stateUpdate(0);
                  currentSN = 1;  break;
          case 1: s28N46S.stateUpdate(1);
                  s1379N5S.stateUpdate(0);
                  currentSN = 2;  break;
          case 2: s5N1379S.stateUpdate(1);
                  s28N46S.stateUpdate(0);
                  currentSN = 3;  break;
          case 3: s46N28S.stateUpdate(1);
                  s5N1379S.stateUpdate(0);
                  currentSN = 0;  break;
          default:currentSN = 0;
        }   //End state switch
      }   //End state change if
      
      //Speed change function
      else if((currentMillis - prevMlsCheck >= systemCheckTime) &&
              (currentSN == 0)) {
        prevMlsCheck = currentMillis;
        periodChange = findPeriodChange(currentPer, currentTar);
        currentPer += periodChange;
        currentInt = currentPer / sysSmlNumStates;        
      }   //End speed change if
    }   //End small stirring while
    
    //Stirring exit
    //TO DO
  }   //End stopStirring if
}   //End loop

/*====================================================================================*/
/* The findPeriodChange function finds how much the period is supposed to change. This
 * is meant to be a percentage change of the current period, set by systemPercent. If
 * this change amount would be more than the difference the target period and the
 * current period, the function will return that difference. */
long findPeriodChange(long inCurPer, long inTarPer) {
  long tempVal;
  long returnVal = (long)((float)inCurPer * systemPercent);
  if(inCurPer > inTarPer) {
    tempVal = inCurPer - inTarPer;
    if(tempVal < returnVal) {
      returnVal = -tempVal;
      return returnVal;
    }
    else {
      returnVal = -returnVal;
      return returnVal;
    }
  }
  else if(inCurPer < inTarPer) {
    tempVal = inTarPer - inCurPer;
    if(tempVal < returnVal) {
      return tempVal;
    }
    else {
      return returnVal;
    }
  }
  else {
    returnVal = 0;
    return returnVal;
  }
}   //End findNumSteps function

/*------------------------------------------------------------------------------------*/
/* The stopInterrupt function simply sets stopStirring to 1, to exit the stirring while
 * loops. Compliant with the Arduino implementation of interrupts, this function must
 * return void and take no parameters. */
void stopInterrupt() {
  stopStirring = 1;
}   //End stopInterrupt function
