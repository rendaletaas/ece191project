class largeOrient {
  int coilPin1;
  int coilPin2;
  volatile long period;       //Period of whole cycle in ms
  volatile long onTime;       //When the coils turn on
  volatile long offTime;      //When the coils turn off
  long bufferTime;            //Length of the between state buffer
  long stateNumber;           //Ordinal number of this state
  volatile int coilState;     //1 if the coil is on
  volatile unsigned long previousMillis;

  public:
  largeOrient(int pin1, int pin2, long inPeriod, long inSN, long inBuffer) {
    coilPin1 = pin1;
    coilPin2 = pin2;
    pinMode(coilPin1, OUTPUT);
    pinMode(coilPin2, OUTPUT);

    stateNumber = inSN;
    period = inPeriod;
    bufferTime = inBuffer;
    onTime = (period / 4) - bufferTime;
    offTime = (3 * (period / 4)) + bufferTime;
    coilState = 0;
    previousMillis = 0;
  }   //End largeOrient constructor 

  int stateUpdate(unsigned long inMillis, int inNumber) {
    if(stateNumber == inNumber) {
      if((coilState == 1) && (inMillis - previousMillis >= onTime)) {
        previousMillis = inMillis;
        coilState = 0;
        digitalWrite(coilPin1, LOW);
        digitalWrite(coilPin2, LOW);
        return 1;
      }
      else if((coilState == 0) && (inMillis - previousMillis >= offTime)) {
        previousMillis = inMillis;
        coilState = 1;
        digitalWrite(coilPin1, HIGH);
        digitalWrite(coilPin2, HIGH);
      }
    }
    return 0;
  }   //End stateUpdate function

  void periodChange(long inPC) {
    period = inPC;
    onTime = (period / 4) - bufferTime;
    offTime = (3 * (period / 4)) + bufferTime;
  }   //End periodChange function

  int getState() {
    return coilState;
  }   //End getState function
};    //End largeOrient class

/*-----------------------------------------------------------------------------------------------------*/
int findNumSteps(long inCurPer, long inTarPer, long inPerCh) {
  long tempVal = inCurPer - inTarPer;
  if(tempVal < 0)
    tempVal = -tempVal;
  int returnVal = (int)(tempVal / inPerCh);
  return returnVal;
}   //End findNumSteps function

/*-----------------------------------------------------------------------------------------------------*/
//Initialize system variables
long systemShortInc = 1;      //Default short increment
long systemLongInc = 5;       //Default long increment
long systemTransition = 100;  //Default transtion from short to long
long systemSP = 2000;         //Default starting period
long systemTP = 1990;         //Default target period
long systemBuffer = 20;       //Default state buffer time
long systemCheckTime = 3000;  //Default time between speed checks

//Initialize largeOrient instances
/* UF/R: 10,11
 * DF/R: 8,9
 * RF/R: 6,7
 * LF/R: 4,5 */
largeOrient upNdownS(10, 9, systemSP, 0, systemBuffer);
largeOrient rightNleftS(6, 5, systemSP, 1, systemBuffer);
largeOrient downNupS(8, 11, systemSP, 2, systemBuffer);
largeOrient leftNrightS(4, 7, systemSP, 3, systemBuffer);

//State Variables
volatile int stopSpinning = 0;
volatile int atSpeed = 0;
volatile int currentSN = 0;
//Time variables
volatile unsigned long currentMillis = 0;
volatile unsigned long previousMillis = 0;
//Period variables
volatile long currentPeriod = systemSP;
volatile long currentTarget = systemTP;
volatile long periodChange = systemLongInc;
volatile int numSteps = 0;

void setup() {
  pinMode(0, OUTPUT);
  pinMode(1, OUTPUT);
  pinMode(2, OUTPUT);
  pinMode(3, OUTPUT);
  numSteps = findNumSteps(currentPeriod, currentTarget, periodChange);
}   //End setup

/*-----------------------------------------------------------------------------------------------------*/

void loop() {
  while(stopSpinning == 0) {
    currentMillis = millis();
    //Rotation cycle
    if(upNdownS.stateUpdate(currentMillis, currentSN)==1)
      currentSN = 1;
    if(rightNleftS.stateUpdate(currentMillis, currentSN)==1)
      currentSN = 2;
    if(downNupS.stateUpdate(currentMillis, currentSN)==1)
      currentSN = 3;
    if(leftNrightS.stateUpdate(currentMillis, currentSN)==1)
      currentSN = 0;

    //Speed change
    if((numSteps > 0) &&
    (currentPeriod != currentTarget) &&
    (currentMillis - previousMillis >= systemCheckTime) &&
    (currentSN == 0)) {
      previousMillis = currentMillis;
      //Determine period change amount
      if(currentPeriod > currentTarget) {
        if(currentPeriod > systemTransition)
          periodChange = -systemLongInc;
        else
          periodChange = -systemShortInc;
      }
      else if(currentPeriod < currentTarget) {
        if(currentPeriod >= systemTransition)
          periodChange = systemLongInc;
        else
          periodChange = systemShortInc;
      }
      else
        periodChange = 0;
      currentPeriod += periodChange;
      upNdownS.periodChange(currentPeriod);
      rightNleftS.periodChange(currentPeriod);
      downNupS.periodChange(currentPeriod);
      leftNrightS.periodChange(currentPeriod);
      numSteps--;
    }   //End speed change if

    //Full speed pin
    if(currentPeriod == currentTarget)
      digitalWrite(0, HIGH);
  }   //End spinning while
}   //End loop
